{% load static %}
<!doctype html>
<html class="dark">
  <head>
    <title>Home</title>
    <link
      rel="icon"
      type="image/png"
      href="{% static 'dshare_icon_bg.png' %}"
    />
    <link rel="apple-touch-icon" href="{% static 'dshare_icon_bg.png' %}" />
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
  </head>
  <body class="bg-black text-white font-sans" style="touch-action: none">
    <div class="min-h-screen flex items-center justify-center">
      <div
        class="pointer-events-none fixed inset-0 flex items-center justify-center select-none"
        style="opacity: 0.12; z-index: 0"
      >
        <img
          src="{% static 'dshare_logo_text.png' %}"
          alt="DShare"
          class="w-56 sm:w-64 md:w-72"
        />
      </div>
      <img
        src="{% static 'dshare_icon.png' %}"
        alt="DShare"
        class="pointer-events-none fixed top-4 left-4 w-8 h-8 opacity-70"
      />
      <div
        id="toast"
        class="hidden fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-white text-black px-4 py-2 rounded opacity-90 text-sm select-none"
      ></div>
      <div
        id="upload-progress"
        class="hidden fixed bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 text-xs tracking-widest text-white opacity-80"
      >
        <div id="upload-progress-label">0%</div>
        <div
          class="w-40 h-1 rounded-full bg-white bg-opacity-10 overflow-hidden"
        >
          <div
            id="upload-progress-bar"
            class="h-1 bg-white"
            style="width: 0%"
          ></div>
        </div>
        <button
          id="upload-toggle"
          type="button"
          class="hidden px-3 py-1 text-[10px] tracking-widest uppercase border border-white/30 text-white/80 hover:text-white"
        >
          Pause
        </button>
      </div>
      <div id="upload-section" class="hidden">
        <form
          id="upload-form"
          method="post"
          enctype="multipart/form-data"
          action="/upload/"
        >
          {% csrf_token %}
          <input type="file" name="file" class="mb-4 p-2 bg-white text-black" />
          <button type="submit" class="p-2 bg-white text-black">
            Upload File
          </button>
        </form>
        <button onclick="pasteText()" class="p-2 bg-white text-black">
          Paste Clipboard
        </button>
      </div>
    </div>
    <canvas id="gesture-canvas" class="fixed inset-0 w-full h-full pointer-events-none" style="z-index: 100;"></canvas>
    <script>
      let keyword = "";
      const specialKeywordUpload = "divya";
      const specialKeywordDownload = "moti";
      const COMMAND_PREFIXES = ["/", "\\"];

      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(";").shift();
        return "";
      }

      function getCsrfToken() {
        const cookie = getCookie("csrftoken");
        if (cookie) return cookie;
        const input = document.querySelector(
          'input[name="csrfmiddlewaretoken"]',
        );
        return input ? input.value : "";
      }

      function toast(message, ms = 1800) {
        const el = document.getElementById("toast");
        el.textContent = message;
        el.classList.remove("hidden");
        clearTimeout(el._t);
        el._t = setTimeout(() => el.classList.add("hidden"), ms);
      }

      const uploadProgressEl = document.getElementById("upload-progress");
      const uploadProgressBar = document.getElementById("upload-progress-bar");
      const uploadProgressLabel = document.getElementById(
        "upload-progress-label",
      );

      function setUploadProgress(percent) {
        const clamped = Math.max(0, Math.min(100, Math.round(percent)));
        uploadProgressLabel.textContent = `${clamped}%`;
        uploadProgressBar.style.width = `${clamped}%`;
        uploadProgressEl.classList.remove("hidden");
      }

      function clearUploadProgress() {
        uploadProgressBar.style.width = "0%";
        uploadProgressLabel.textContent = "0%";
        uploadProgressEl.classList.add("hidden");
      }

      const CHUNK_SIZE = 1024 * 1024;
      const uploadToggle = document.getElementById("upload-toggle");
      let uploadPaused = false;
      let uploadInProgress = false;

      function updateUploadToggle() {
        if (!uploadInProgress) {
          uploadToggle.classList.add("hidden");
          return;
        }
        uploadToggle.textContent = uploadPaused ? "Resume" : "Pause";
        uploadToggle.classList.remove("hidden");
      }

      uploadToggle.addEventListener("click", () => {
        if (!uploadInProgress) return;
        uploadPaused = !uploadPaused;
        updateUploadToggle();
        toast(uploadPaused ? "paused" : "resumed", 900);
      });

      function waitWhilePaused() {
        return new Promise((resolve) => {
          const tick = () => {
            if (!uploadPaused) {
              resolve();
              return;
            }
            setTimeout(tick, 150);
          };
          tick();
        });
      }

      function fileUploadKey(file) {
        return `dshare-upload:${file.name}:${file.size}:${file.lastModified}`;
      }

      function loadUploadSession(key) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : null;
        } catch (_) {
          return null;
        }
      }

      function saveUploadSession(key, session) {
        try {
          localStorage.setItem(key, JSON.stringify(session));
        } catch (_) {}
      }

      function clearUploadSession(key) {
        try {
          localStorage.removeItem(key);
        } catch (_) {}
      }

      function base64urlToUint8Array(base64url) {
        const padding = "=".repeat((4 - (base64url.length % 4)) % 4);
        const base64 = (base64url + padding)
          .replace(/-/g, "+")
          .replace(/_/g, "/");
        const raw = atob(base64);
        const out = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
        return out;
      }

      function uint8ArrayToBase64url(bytes) {
        let binary = "";
        for (let i = 0; i < bytes.length; i++)
          binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        return base64
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/g, "");
      }

      function bufferToBase64url(buf) {
        return uint8ArrayToBase64url(new Uint8Array(buf));
      }

      function preformatCreateOptions(opts) {
        const out = { ...opts };
        out.challenge = base64urlToUint8Array(out.challenge);
        out.user = { ...out.user, id: base64urlToUint8Array(out.user.id) };
        if (out.excludeCredentials) {
          out.excludeCredentials = out.excludeCredentials.map((c) => ({
            ...c,
            id: base64urlToUint8Array(c.id),
          }));
        }
        return out;
      }

      function preformatGetOptions(opts) {
        const out = { ...opts };
        out.challenge = base64urlToUint8Array(out.challenge);
        if (out.allowCredentials) {
          out.allowCredentials = out.allowCredentials.map((c) => ({
            ...c,
            id: base64urlToUint8Array(c.id),
          }));
        }
        return out;
      }

      function credentialToJSON(cred) {
        if (!cred) return null;
        const response = cred.response || {};
        const clientExtensionResults = cred.getClientExtensionResults
          ? cred.getClientExtensionResults()
          : {};
        const rawId = bufferToBase64url(cred.rawId);
        const obj = {
          id: rawId,
          rawId,
          type: cred.type,
          authenticatorAttachment: cred.authenticatorAttachment || null,
          clientExtensionResults,
          response: {
            clientDataJSON: bufferToBase64url(response.clientDataJSON),
          },
        };
        if (response.attestationObject) {
          obj.response.attestationObject = bufferToBase64url(
            response.attestationObject,
          );
        }
        if (response.authenticatorData) {
          obj.response.authenticatorData = bufferToBase64url(
            response.authenticatorData,
          );
        }
        if (response.signature) {
          obj.response.signature = bufferToBase64url(response.signature);
        }
        if (response.userHandle) {
          obj.response.userHandle = bufferToBase64url(response.userHandle);
        }
        return obj;
      }

      async function postJSON(url, data) {
        const csrftoken = getCsrfToken();
        const res = await fetch(url, {
          method: "POST",
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrftoken,
          },
          body: JSON.stringify(data || {}),
        });
        return res;
      }

      async function refreshMode() {
        try {
          await fetch("/api/auth/me/", { method: "GET" });
        } catch (_) {}
      }

      function promptPassword(message) {
        return new Promise((resolve) => {
          const modal = document.createElement("div");
          modal.className =
            "fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50";
          modal.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded shadow-lg flex flex-col gap-4 w-80">
                        <label class="text-white text-sm font-bold">${message}</label>
                        <input type="password" id="modal-input" class="p-2 bg-gray-700 text-white rounded outline-none focus:ring-2 focus:ring-blue-500" autofocus>
                        <div class="flex justify-end gap-2">
                            <button id="modal-cancel" class="px-4 py-2 bg-gray-600 text-white rounded hover:bg-gray-500">Cancel</button>
                            <button id="modal-ok" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-500">OK</button>
                        </div>
                    </div>
                `;
          document.body.appendChild(modal);

          const input = modal.querySelector("#modal-input");
          const okBtn = modal.querySelector("#modal-ok");
          const cancelBtn = modal.querySelector("#modal-cancel");

          function close(val) {
            modal.remove();
            resolve(val);
          }

          okBtn.onclick = () => close(input.value);
          cancelBtn.onclick = () => close(null);
          input.onkeydown = (e) => {
            if (e.key === "Enter") close(input.value);
            if (e.key === "Escape") close(null);
          };

          // Allow clicking outside to cancel
          modal.onclick = (e) => {
            if (e.target === modal) close(null);
          };

          input.focus();
        });
      }

      async function commandRegister() {
        const email = prompt("email");
        if (!email) return;

        let canLogin = false;
        try {
          const statusRes = await postJSON("/api/auth/email-status/", {
            email,
          });
          const statusData = await statusRes.json();
          canLogin =
            statusRes.ok &&
            statusData &&
            statusData.status === "ok" &&
            !!statusData.can_login;
        } catch (_) {}

        if (canLogin) {
          const secret = await promptPassword("Enter password or pin");
          if (!secret) {
            toast("fail");
            return;
          }
          const res = await postJSON("/api/auth/login/", { email, secret });
          let data = null;
          try {
            data = await res.json();
          } catch (_) {}
          if (res.ok && data && data.status === "ok") {
            toast("ok");
            await refreshMode();
            return;
          }
          toast("fail");
          return;
        }

        const password = await promptPassword("Create password");
        if (!password) {
          toast("fail");
          return;
        }
        const pin = (await promptPassword("Create pin (optional)")) || "";
        const res = await postJSON("/api/auth/register/", {
          email,
          password,
          pin,
        });
        let data = null;
        try {
          data = await res.json();
        } catch (_) {}
        if (res.ok && data && data.status === "ok") {
          toast("sent");
          return;
        }
        if (data && data.detail) console.error(data.detail);
        toast("fail");
      }

      async function tryPasskeyLogin() {
        if (!window.PublicKeyCredential) return false;
        try {
          const begin = await postJSON("/api/webauthn/auth/begin/", {});
          if (!begin.ok) return false;
          const options = await begin.json();
          const publicKey = preformatGetOptions(options.publicKey);
          const assertion = await navigator.credentials.get({ publicKey });
          const payload = credentialToJSON(assertion);
          const complete = await postJSON(
            "/api/webauthn/auth/complete/",
            payload,
          );
          if (!complete.ok) return false;
          const out = await complete.json();
          return out && out.status === "ok";
        } catch (_) {
          return false;
        }
      }

      async function commandLogin() {
        const passkeyOk = await tryPasskeyLogin();
        if (passkeyOk) {
          toast("ok");
          await refreshMode();
          return;
        }

        const email = prompt("email");
        if (!email) return;
        const secret = await promptPassword("Enter password or pin");
        if (!secret) {
          toast("fail");
          return;
        }
        const res = await postJSON("/api/auth/login/", { email, secret });
        let data = null;
        try {
          data = await res.json();
        } catch (_) {}
        if (res.ok && data && data.status === "ok") {
          toast("ok");
          await refreshMode();
          return;
        }
        toast("fail");
      }

      async function commandLogout() {
        const res = await postJSON("/api/auth/logout/", {});
        toast(res.ok ? "ok" : "fail");
        await refreshMode();
      }

      async function commandPasskey() {
        if (!window.PublicKeyCredential) {
          toast("fail");
          return;
        }
        try {
          const begin = await postJSON("/api/webauthn/register/begin/", {});
          if (!begin.ok) {
            toast("fail");
            return;
          }
          const options = await begin.json();
          const publicKey = preformatCreateOptions(options.publicKey);
          const cred = await navigator.credentials.create({ publicKey });
          const payload = credentialToJSON(cred);
          const complete = await postJSON(
            "/api/webauthn/register/complete/",
            payload,
          );
          toast(complete.ok ? "ok" : "fail");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandCopy() {
        try {
          const res = await fetch("/api/share/text/", { method: "GET" });
          const data = await res.json();
          const text = data && data.text ? data.text : "";
          await navigator.clipboard.writeText(text);
          toast("ok");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandClear() {
        try {
          await postJSON("/api/share/clear/", {});
          try {
            await navigator.clipboard.writeText("");
          } catch (_) {}
          toast("ok");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandHelp() {
        toast(
          "draw R/L/P/S/C/M/K/H, up/down | type /register /login /logout /passkey /status /me /copy /paste /clear",
          3500,
        );
      }

      async function commandStatus() {
        try {
          const res = await fetch("/api/auth/me/", { method: "GET" });
          const data = await res.json();
          toast(data && data.authenticated ? "private" : "public");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandMe() {
        try {
          const res = await fetch("/api/auth/me/", { method: "GET" });
          const data = await res.json();
          if (!data || !data.authenticated) {
            toast("me: public");
            return;
          }
          const summary = `me: verified=${!!data.email_verified} passkey=${!!data.has_passkey} pw=${!!data.has_password} pin=${!!data.has_pin}`;
          toast(summary, 3000);
        } catch (_) {
          toast("fail");
        }
      }

      async function handleCommand(cmd) {
        if (cmd === "register") return commandRegister();
        if (cmd === "login") return commandLogin();
        if (cmd === "logout") return commandLogout();
        if (cmd === "passkey") return commandPasskey();
        if (cmd === "status") return commandStatus();
        if (cmd === "me") return commandMe();
        if (cmd === "copy") return commandCopy();
        if (cmd === "paste") return pasteText();
        if (cmd === "clear") return commandClear();
        if (cmd === "help" || cmd === "?") return commandHelp();
        toast("fail");
      }

      document.addEventListener("keydown", function (e) {
        const active = document.activeElement;
        if (
          active &&
          (active.tagName === "INPUT" || active.tagName === "TEXTAREA")
        )
          return;
        if (e.key.length !== 1) return;
        keyword += e.key.toLowerCase();
        if (keyword.length > 64) keyword = keyword.slice(-64);

        if (keyword.includes(specialKeywordUpload)) {
          document.getElementById("upload-section").classList.remove("hidden");
          keyword = ""; // Reset keyword
        }
        if (keyword.includes(specialKeywordDownload)) {
          window.location.href = "/download/";
          keyword = ""; // Reset keyword
        }

        for (const prefix of COMMAND_PREFIXES) {
          const idx = keyword.lastIndexOf(prefix);
          if (idx === -1) continue;
          const maybe = keyword.slice(idx + 1);
          const known = [
            "register",
            "login",
            "logout",
            "passkey",
            "status",
            "me",
            "copy",
            "paste",
            "clear",
            "help",
            "?",
          ];
          if (known.includes(maybe)) {
            keyword = "";
            handleCommand(maybe);
            break;
          }
        }
      });

      async function pasteText() {
        try {
          const text = await navigator.clipboard.readText();
          const formData = new FormData();
          formData.append("text", text);
          const response = await fetch("/upload/", {
            method: "POST",
            credentials: "same-origin",
            body: formData,
            headers: {
              "X-CSRFToken": getCsrfToken(),
            },
          });
          let data = null;
          try {
            data = await response.json();
          } catch (_) {}
          toast(response.ok && data && data.status === "ok" ? "ok" : "fail");
        } catch (_) {
          toast("fail");
        }
      }

      function chunkSizeForIndex(file, index, chunkSize) {
        const start = index * chunkSize;
        return Math.min(chunkSize, file.size - start);
      }

      async function startUploadSession(file, cached) {
        const payload = {
          filename: file.name,
          size: file.size,
          chunk_size: CHUNK_SIZE,
          content_type: file.type || "",
        };
        if (cached && cached.upload_id) {
          payload.upload_id = cached.upload_id;
        }
        const res = await postJSON("/api/upload/start/", payload);
        const data = await res.json();
        if (!res.ok || !data || data.status !== "ok") {
          throw new Error("upload start failed");
        }
        return data;
      }

      async function uploadChunkedFile(file) {
        if (!file || file.size <= 0) {
          throw new Error("empty file");
        }
        uploadInProgress = true;
        uploadPaused = false;
        updateUploadToggle();
        setUploadProgress(0);
        if ("Notification" in window && Notification.permission === "default") {
          Notification.requestPermission().catch(() => {});
        }

        const key = fileUploadKey(file);
        const cached = loadUploadSession(key);
        const session = await startUploadSession(file, cached);
        saveUploadSession(key, {
          upload_id: session.upload_id,
          chunk_size: session.chunk_size,
        });

        const chunkSize = session.chunk_size || CHUNK_SIZE;
        const totalChunks = session.total_chunks;
        const received = new Set(session.received_chunks || []);
        let uploadedBytes = 0;
        for (const idx of received) {
          if (typeof idx !== "number") continue;
          uploadedBytes += chunkSizeForIndex(file, idx, chunkSize);
        }
        setUploadProgress((uploadedBytes / file.size) * 100);

        for (let index = 0; index < totalChunks; index++) {
          if (received.has(index)) {
            continue;
          }
          await waitWhilePaused();
          const start = index * chunkSize;
          const chunk = file.slice(start, start + chunkSize);
          const formData = new FormData();
          formData.append("upload_id", session.upload_id);
          formData.append("index", String(index));
          formData.append("chunk", chunk, file.name);
          const res = await fetch("/api/upload/chunk/", {
            method: "POST",
            credentials: "same-origin",
            headers: {
              "X-CSRFToken": getCsrfToken(),
            },
            body: formData,
          });
          if (!res.ok) {
            throw new Error("chunk upload failed");
          }
          received.add(index);
          uploadedBytes += chunk.size;
          setUploadProgress((uploadedBytes / file.size) * 100);
        }

        const complete = await postJSON("/api/upload/complete/", {
          upload_id: session.upload_id,
        });
        const completeData = await complete.json();
        if (!complete.ok || !completeData || completeData.status !== "ok") {
          throw new Error("upload complete failed");
        }
        clearUploadSession(key);
        return true;
      }

      document
        .getElementById("upload-form")
        .addEventListener("submit", function (e) {
          e.preventDefault();
          if (uploadInProgress) {
            toast("busy");
            return;
          }
          const fileInput = this.querySelector('input[type="file"]');
          const file = fileInput && fileInput.files ? fileInput.files[0] : null;
          if (!file) {
            toast("fail");
            return;
          }
          uploadChunkedFile(file)
            .then(() => {
              toast("ok");
              if (
                "Notification" in window &&
                Notification.permission === "granted"
              ) {
                new Notification("DShare", { body: "Upload complete." });
              }
            })
            .catch(() => toast("fail"))
            .finally(() => {
              uploadInProgress = false;
              updateUploadToggle();
              clearUploadProgress();
            });
        });

      refreshMode();

      const params = new URLSearchParams(window.location.search);
      if (params.get("verified") === "1" || params.get("setup") === "passkey") {
        toast("ok");
        params.delete("verified");
        params.delete("setup");
        const q = params.toString();
        const clean = q
          ? `${window.location.pathname}?${q}`
          : window.location.pathname;
        window.history.replaceState({}, "", clean);
      }

      // --- Gesture Recognition (Ported from Flutter) ---
      class Point { constructor(x, y) { this.x = x; this.y = y; } }
      class Recognizer {
        constructor() {
          this.points = [];
          this.templates = [
            { name: 'UP', points: [new Point(0, 100), new Point(0, 0)] },
            { name: 'ARROW_UP', points: [new Point(0, 100), new Point(50, 0), new Point(100, 100)] },
            { name: 'DOWN', points: [new Point(0, 0), new Point(0, 100)] },
            { name: 'ARROW_DOWN', points: [new Point(0, 0), new Point(50, 100), new Point(100, 0)] },
            { name: 'L', points: [new Point(0, 0), new Point(0, 100), new Point(50, 100)] },
            { name: 'R', points: [new Point(0, 100), new Point(0, 0), new Point(50, 0), new Point(50, 50), new Point(0, 50), new Point(50, 100)] },
            { name: 'P', points: [new Point(0, 100), new Point(0, 0), new Point(50, 0), new Point(50, 50), new Point(0, 50)] },
            { name: 'C', points: [new Point(100, 0), new Point(0, 50), new Point(100, 100)] },
            { name: 'S', points: [new Point(100, 0), new Point(0, 30), new Point(100, 70), new Point(0, 100)] },
            { name: 'M', points: [new Point(0, 100), new Point(0, 0), new Point(50, 50), new Point(100, 0), new Point(100, 100)] },
            { name: 'H', points: [new Point(0, 0), new Point(0, 100), new Point(0, 50), new Point(100, 50), new Point(100, 0), new Point(100, 100)] },
            { name: 'K', points: [new Point(0, 0), new Point(0, 100), new Point(0, 50), new Point(50, 0), new Point(0, 50), new Point(50, 100)] },
          ];
          // Pre-process templates
          const numPoints = 64;
          const squareSize = 250.0;
          this.templates = this.templates.map(t => ({
             name: t.name,
             points: this.normalize(t.points, numPoints, squareSize)
          }));
          this.numPoints = numPoints;
          this.squareSize = squareSize;
        }

        recognize(points) {
          if (points.length < 10) return null;
          points = this.normalize(points, this.numPoints, this.squareSize);
          let bestDist = Infinity;
          let bestName = '';
          for (const t of this.templates) {
            const d = this.distanceAtBestAngle(points, t.points);
            if (d < bestDist) {
               bestDist = d;
               bestName = t.name;
            }
          }
          const score = 1.0 - (bestDist / (0.5 * Math.sqrt(this.squareSize*this.squareSize + this.squareSize*this.squareSize)));
          return { name: bestName, score: score };
        }

        normalize(points, n, size) {
           return this.translateToOrigin(this.scaleToSquare(this.rotateToZero(this.resample(points, n)), size));
        }

        resample(points, n) {
           let I = this.pathLength(points) / (n - 1);
           let D = 0.0;
           let newPoints = [points[0]];
           for (let i = 1; i < points.length; i++) {
               let d = this.distance(points[i-1], points[i]);
               if (D + d >= I) {
                   let qx = points[i-1].x + ((I - D) / d) * (points[i].x - points[i-1].x);
                   let qy = points[i-1].y + ((I - D) / d) * (points[i].y - points[i-1].y);
                   let q = new Point(qx, qy);
                   newPoints.push(q);
                   points.splice(i, 0, q);
                   D = 0.0;
               } else { D += d; }
           }
           if (newPoints.length === n - 1) newPoints.push(points[points.length - 1]);
           return newPoints;
        }
        
        rotateToZero(points) {
            const c = this.centroid(points);
            const theta = Math.atan2(c.y - points[0].y, c.x - points[0].x);
            return this.rotateBy(points, -theta);
        }
        
        rotateBy(points, rads) {
            const c = this.centroid(points);
            const cos = Math.cos(rads);
            const sin = Math.sin(rads);
            return points.map(p => new Point(
                (p.x - c.x) * cos - (p.y - c.y) * sin + c.x,
                (p.x - c.x) * sin + (p.y - c.y) * cos + c.y
            ));
        }

        scaleToSquare(points, size) {
            const b = this.boundingBox(points);
            const w = b.w === 0 ? 1 : b.w;
            const h = b.h === 0 ? 1 : b.h;
            return points.map(p => new Point(p.x * (size / w), p.y * (size / h)));
        }

        translateToOrigin(points) {
            const c = this.centroid(points);
            return points.map(p => new Point(p.x - c.x, p.y - c.y));
        }
        
        distanceAtBestAngle(points, T) {
            let a = -45.0 * (Math.PI / 180.0);
            let b = 45.0 * (Math.PI / 180.0);
            const phi = 0.618033988749895;
            let x1 = phi * a + (1.0 - phi) * b;
            let f1 = this.distanceAtAngle(points, T, x1);
            let x2 = (1.0 - phi) * a + phi * b;
            let f2 = this.distanceAtAngle(points, T, x2);
            while (Math.abs(b - a) > 2.0 * (Math.PI / 180.0)) {
                if (f1 < f2) {
                    b = x2; x2 = x1; f2 = f1;
                    x1 = phi * a + (1.0 - phi) * b;
                    f1 = this.distanceAtAngle(points, T, x1);
                } else {
                    a = x1; x1 = x2; f1 = f2;
                    x2 = (1.0 - phi) * a + phi * b;
                    f2 = this.distanceAtAngle(points, T, x2);
                }
            }
            return Math.min(f1, f2);
        }

        distanceAtAngle(points, T, rads) {
            let newPoints = this.rotateBy(points, rads);
            let d = 0.0;
            for (let i = 0; i < points.length; i++) d += this.distance(newPoints[i], T[i]);
            return d / points.length;
        }

        pathLength(points) {
            let d = 0.0;
            for (let i = 1; i < points.length; i++) d += this.distance(points[i-1], points[i]);
            return d;
        }

        distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        centroid(points) {
            let x = 0, y = 0;
            for (const p of points) { x += p.x; y += p.y; }
            return new Point(x / points.length, y / points.length);
        }

        boundingBox(points) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const p of points) {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }
            return { w: maxX - minX, h: maxY - minY };
        }
      }

      // --- Interaction ---
      const recognizer = new Recognizer();
      let stroke = [];
      const canvas = document.getElementById('gesture-canvas');
      const ctx = canvas.getContext('2d');
      let isDrawing = false;

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function drawStroke() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (stroke.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.moveTo(stroke[0].x, stroke[0].y);
        for (let i = 1; i < stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
        ctx.stroke();
      }

      const DRAW_THRESHOLD = 6;
      const GESTURE_SCORE_THRESHOLD = 0.72;
      let activePointerId = null;
      let activePointerTarget = null;
      let strokeMoved = false;

      function isInteractiveTarget(target) {
        if (!target || !target.closest) return false;
        return !!target.closest("button, input, textarea, select, a, label");
      }

      function beginStroke(x, y) {
        stroke = [new Point(x, y)];
        isDrawing = true;
        strokeMoved = false;
      }

      function extendStroke(x, y) {
        if (!isDrawing) return;
        stroke.push(new Point(x, y));
        if (!strokeMoved) {
          const dx = x - stroke[0].x;
          const dy = y - stroke[0].y;
          if (Math.hypot(dx, dy) > DRAW_THRESHOLD) {
            strokeMoved = true;
          }
        }
        requestAnimationFrame(drawStroke);
      }

      function verticalSwipeDirection(points) {
        if (!points || points.length < 2) return null;
        const minDy = Math.max(50, window.innerHeight * 0.06);
        const maxDx = Math.max(220, window.innerWidth * 0.65);
        let minX = points[0].x;
        let maxX = points[0].x;
        let minY = points[0].y;
        let maxY = points[0].y;
        let sumAbsDx = 0;
        let sumAbsDy = 0;
        let posDySegments = 0;
        let negDySegments = 0;
        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1];
          const curr = points[i];
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          sumAbsDx += Math.abs(dx);
          sumAbsDy += Math.abs(dy);
          if (dy > 2) {
            posDySegments += 1;
          } else if (dy < -2) {
            negDySegments += 1;
          }
          if (curr.x < minX) minX = curr.x;
          if (curr.x > maxX) maxX = curr.x;
          if (curr.y < minY) minY = curr.y;
          if (curr.y > maxY) maxY = curr.y;
        }
        const dxRange = maxX - minX;
        const dyRange = maxY - minY;
        if (dyRange < minDy) return null;
        if (dxRange > maxDx) return null;
        if (sumAbsDy <= 0) return null;
        const dominance = sumAbsDx === 0 ? Infinity : (sumAbsDy / sumAbsDx);
        if (dominance < 1.05) return null;
        const totalDy = posDySegments + negDySegments;
        if (totalDy > 0) {
          const dominant = Math.max(posDySegments, negDySegments) / totalDy;
          if (dominant < 0.6) return null;
        }
        const netDy = points[points.length - 1].y - points[0].y;
        if (Math.abs(netDy) < dyRange * 0.35) return null;
        return netDy < 0 ? "UP" : "DOWN";
      }

      function verticalSwipeFallback(points) {
        if (!points || points.length < 2) return null;
        const minDy = Math.max(40, window.innerHeight * 0.05);
        const netDy = points[points.length - 1].y - points[0].y;
        const netDx = points[points.length - 1].x - points[0].x;
        if (Math.abs(netDy) < minDy) return null;
        if (Math.abs(netDy) < Math.abs(netDx) * 1.1) return null;
        return netDy < 0 ? "UP" : "DOWN";
      }

      function finishStroke() {
        if (!isDrawing) return;
        isDrawing = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const vertical = verticalSwipeDirection(stroke);
        if (vertical === "UP") {
          document.getElementById("upload-section").classList.remove("hidden");
          keyword = "";
          stroke = [];
          return;
        }
        if (vertical === "DOWN") {
          window.location.href = "/download/";
          stroke = [];
          return;
        }

        const fallback = verticalSwipeFallback(stroke);
        if (fallback === "UP") {
          document.getElementById("upload-section").classList.remove("hidden");
          keyword = "";
          stroke = [];
          return;
        }
        if (fallback === "DOWN") {
          window.location.href = "/download/";
          stroke = [];
          return;
        }

        if (stroke.length < 10) {
          stroke = [];
          return;
        }

        const result = recognizer.recognize(stroke);
        stroke = [];

        if (result && result.score > GESTURE_SCORE_THRESHOLD) {
          if (result.name === 'UP' || result.name === 'ARROW_UP') {
            document.getElementById("upload-section").classList.remove("hidden");
            keyword = "";
          } else if (result.name === 'DOWN' || result.name === 'ARROW_DOWN') {
            window.location.href = "/download/";
          } else if (result.name === 'R') {
            commandRegister();
          } else if (result.name === 'L') {
            commandLogin();
          } else if (result.name === 'P') {
            pasteText();
          } else if (result.name === 'S') {
            commandStatus();
          } else if (result.name === 'C') {
            commandCopy();
          } else if (result.name === 'M') {
            commandMe();
          } else if (result.name === 'K') {
            commandPasskey();
          } else if (result.name === 'H') {
            commandHelp();
          } else {
            toast("fail");
          }
        } else {
          toast("fail");
        }
      }

      function cancelStroke() {
        if (!isDrawing) return;
        isDrawing = false;
        stroke = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function onPointerDown(e) {
        if (activePointerId !== null) return;
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        if (isInteractiveTarget(e.target)) return;
        activePointerId = e.pointerId;
        activePointerTarget = e.target;
        if (activePointerTarget && activePointerTarget.setPointerCapture) {
          activePointerTarget.setPointerCapture(e.pointerId);
        }
        beginStroke(e.clientX, e.clientY);
      }

      function onPointerMove(e) {
        if (!isDrawing || e.pointerId !== activePointerId) return;
        extendStroke(e.clientX, e.clientY);
        if (strokeMoved) e.preventDefault();
      }

      function clearPointerCapture() {
        if (
          activePointerTarget &&
          activePointerTarget.releasePointerCapture &&
          activePointerId !== null
        ) {
          try {
            activePointerTarget.releasePointerCapture(activePointerId);
          } catch (_) {}
        }
        activePointerId = null;
        activePointerTarget = null;
        strokeMoved = false;
      }

      function onPointerUp(e) {
        if (e.pointerId !== activePointerId) return;
        finishStroke();
        clearPointerCapture();
      }

      function onPointerCancel(e) {
        if (e.pointerId !== activePointerId) return;
        cancelStroke();
        clearPointerCapture();
      }

      function onTouchStart(e) {
        if (e.touches.length > 1) return;
        if (isInteractiveTarget(e.target)) return;
        beginStroke(e.touches[0].clientX, e.touches[0].clientY);
      }

      function onTouchMove(e) {
        if (!isDrawing) return;
        extendStroke(e.touches[0].clientX, e.touches[0].clientY);
        if (strokeMoved) e.preventDefault();
      }

      function onTouchEnd() {
        finishStroke();
      }

      function onTouchCancel() {
        cancelStroke();
      }

      // Tap handler for help (if not clicking something else)
      document.addEventListener('click', (e) => {
        if (isInteractiveTarget(e.target)) return;
        commandHelp();
      });

      if ("PointerEvent" in window) {
        document.addEventListener('pointerdown', onPointerDown, { passive: false });
        document.addEventListener('pointermove', onPointerMove, { passive: false });
        document.addEventListener('pointerup', onPointerUp, { passive: false });
        document.addEventListener('pointercancel', onPointerCancel, { passive: false });
      } else {
        document.addEventListener('touchstart', onTouchStart, { passive: false });
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd, { passive: false });
        document.addEventListener('touchcancel', onTouchCancel, { passive: false });
      }
    </script>
  </body>
</html>
