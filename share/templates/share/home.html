{% load static %}
<!doctype html>
<html class="dark">
  <head>
    <title>Home</title>
    <link
      rel="icon"
      type="image/png"
      href="{% static 'dshare_icon_bg.png' %}"
    />
    <link rel="apple-touch-icon" href="{% static 'dshare_icon_bg.png' %}" />
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      .dshare-glass {
        background:
          radial-gradient(
            120% 120% at 10% 0%,
            rgba(168, 85, 247, 0.18),
            transparent 55%
          ),
          radial-gradient(
            120% 120% at 90% 10%,
            rgba(236, 72, 153, 0.14),
            transparent 60%
          ),
          rgba(0, 0, 0, 0.72);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.65);
        backdrop-filter: blur(14px);
        -webkit-backdrop-filter: blur(14px);
      }
    </style>
  </head>
  <body class="bg-black text-white font-sans" style="touch-action: none">
    <div class="min-h-screen flex items-center justify-center">
      <div
        class="pointer-events-none fixed inset-0 flex items-center justify-center select-none"
        style="opacity: 0.12; z-index: 0"
      >
        <img
          src="{% static 'dshare_logo_text.png' %}"
          alt="DShare"
          class="w-56 sm:w-64 md:w-72"
        />
      </div>
      <button
        id="open-actions"
        type="button"
        class="fixed top-4 left-4 z-40 flex h-9 w-9 items-center justify-center rounded-full border border-white border-opacity-10 bg-black bg-opacity-30 shadow-lg focus:outline-none focus:ring-2 focus:ring-white focus:ring-opacity-20"
        style="backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);"
        aria-label="Open actions"
      >
        <img
          src="{% static 'dshare_icon.png' %}"
          alt="DShare"
          class="h-6 w-6 opacity-80"
        />
      </button>
      <button
        id="open-actions-label"
        type="button"
        class="fixed top-4 left-14 z-40 text-left text-xs tracking-widest text-white focus:outline-none"
        aria-label="Open actions"
      >
        <div id="mode-label">public</div>
        <div id="account-label" class="text-xs tracking-normal text-white text-opacity-60"></div>
      </button>
      <div
        id="toast"
        class="dshare-glass hidden fixed bottom-24 left-1/2 z-50 max-w-sm -translate-x-1/2 rounded-lg px-4 py-3 text-xs tracking-wide leading-relaxed text-white select-none"
        style="white-space: pre-wrap;"
      ></div>
      <div
        id="upload-progress"
        class="hidden fixed bottom-6 left-1/2 -translate-x-1/2 flex flex-col items-center gap-2 text-xs tracking-widest text-white opacity-80"
      >
        <div id="upload-progress-label">0%</div>
        <div
          class="w-40 h-1 rounded-full bg-white bg-opacity-10 overflow-hidden"
        >
          <div
            id="upload-progress-bar"
            class="h-1 bg-white"
            style="width: 0%"
          ></div>
        </div>
        <button
          id="upload-toggle"
          type="button"
          class="hidden px-3 py-1 text-xs tracking-widest uppercase border border-white border-opacity-30 text-white text-opacity-80 hover:bg-white hover:bg-opacity-5 hover:text-opacity-100"
        >
          Pause
        </button>
      </div>
      <div id="upload-section" class="hidden">
        <form
          id="upload-form"
          method="post"
          enctype="multipart/form-data"
          action="/upload/"
        >
          {% csrf_token %}
          <input type="file" name="file" class="mb-4 p-2 bg-white text-black" />
          <button type="submit" class="p-2 bg-white text-black">
            Upload File
          </button>
        </form>
        <button onclick="pasteText()" class="p-2 bg-white text-black">
          Paste Clipboard
        </button>
      </div>
      <div
        id="action-sheet"
        class="hidden fixed inset-0 z-50 flex items-start justify-center bg-black bg-opacity-90 text-white"
      >
        <div
          class="dshare-glass mt-20 w-full max-w-xs mx-4 rounded-lg p-4"
        >
          <div class="text-xs uppercase tracking-widest text-white text-opacity-60">
            Actions
          </div>
          <div id="action-account" class="mt-2 text-xs text-white text-opacity-70"></div>
          <div class="mt-4 grid gap-2 text-sm">
            <button data-action="upload" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Upload file</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">↑ divya</span>
              </div>
            </button>
            <button data-action="download" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Download</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">↓ moti</span>
              </div>
            </button>
            <button data-action="paste" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Paste clipboard</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">→ /paste</span>
              </div>
            </button>
            <button data-action="copy" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Copy to clipboard</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">← /copy</span>
              </div>
            </button>
            <button data-action="status" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Status</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/status</span>
              </div>
            </button>
            <button data-action="me" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Me</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/me</span>
              </div>
            </button>
            <button data-action="passkey" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Passkey</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/passkey</span>
              </div>
            </button>
            <button data-action="register" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Register</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/register</span>
              </div>
            </button>
            <button data-action="login" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Login</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/login</span>
              </div>
            </button>
            <button data-action="logout" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Logout</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/logout</span>
              </div>
            </button>
            <button data-action="clear" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Clear</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">/clear</span>
              </div>
            </button>
            <button data-action="docs" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Docs</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">docs.dshare.me</span>
              </div>
            </button>
            <button data-action="help" type="button" class="w-full rounded border border-white border-opacity-20 px-3 py-2 text-left hover:bg-white hover:bg-opacity-5">
              <div class="flex items-center justify-between gap-4">
                <span>Help</span>
                <span class="text-xs tracking-widest text-white text-opacity-50">? · /help</span>
              </div>
            </button>
          </div>
          <button
            id="action-close"
            type="button"
            class="mt-4 w-full rounded border border-white border-opacity-20 px-3 py-2 text-xs uppercase tracking-widest text-white text-opacity-70 hover:bg-white hover:bg-opacity-5"
          >
            Close
          </button>
        </div>
      </div>
      <div
        id="help-sheet"
        class="hidden fixed inset-0 z-50 flex items-start justify-center bg-black bg-opacity-90 text-white"
      >
        <div
          class="dshare-glass mt-20 w-full max-w-sm mx-4 rounded-lg p-4"
        >
          <div class="flex items-center justify-between gap-4">
            <div class="text-xs uppercase tracking-widest text-white text-opacity-60">
              Hints
            </div>
            <button
              id="help-close"
              type="button"
              class="rounded border border-white border-opacity-20 px-2 py-1 text-xs uppercase tracking-widest text-white text-opacity-70 hover:bg-white hover:bg-opacity-5"
            >
              Close
            </button>
          </div>
          <div class="mt-3 space-y-2 text-sm text-white text-opacity-80">
            <div><span class="font-mono">↑</span> Upload <span class="text-xs text-white text-opacity-60">(type <span class="font-mono">divya</span>)</span></div>
            <div><span class="font-mono">↓</span> Download <span class="text-xs text-white text-opacity-60">(type <span class="font-mono">moti</span>)</span></div>
            <div><span class="font-mono">←</span> Copy latest text</div>
            <div><span class="font-mono">→</span> Paste clipboard text</div>
            <div><span class="font-mono">Hold</span> anywhere (or tap the logo) for Actions</div>
          </div>
          <div class="mt-4 text-xs uppercase tracking-widest text-white text-opacity-60">
            Commands
          </div>
          <div class="mt-2 flex flex-wrap gap-2 text-xs">
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/register</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/login</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/logout</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/passkey</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/status</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/me</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/copy</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/paste</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/clear</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/docs</span>
            <span class="rounded border border-white border-opacity-10 px-2 py-1 text-white text-opacity-70 font-mono">/help</span>
          </div>
          <div class="mt-4 text-xs tracking-wide text-white text-opacity-60">
            Docs: <a href="https://docs.dshare.me" target="_blank" rel="noopener noreferrer" class="underline text-white text-opacity-80 hover:text-opacity-100">docs.dshare.me</a>
          </div>
        </div>
      </div>
    </div>
    <canvas id="gesture-canvas" class="fixed inset-0 w-full h-full pointer-events-none" style="z-index: 100;"></canvas>
    <script>
      let keyword = "";
      const specialKeywordUpload = "divya";
      const specialKeywordDownload = "moti";
      const COMMAND_PREFIXES = ["/", "\\"];

      function getCookie(name) {
        const value = `; ${document.cookie}`;
        const parts = value.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(";").shift();
        return "";
      }

      function getCsrfToken() {
        const cookie = getCookie("csrftoken");
        if (cookie) return cookie;
        const input = document.querySelector(
          'input[name="csrfmiddlewaretoken"]'
        );
        return input ? input.value : "";
      }

      function toast(message, ms = 1800) {
        const el = document.getElementById("toast");
        el.textContent = message;
        el.classList.remove("hidden");
        clearTimeout(el._t);
        el._t = setTimeout(() => el.classList.add("hidden"), ms);
      }

      function toastAuthFailure(res) {
        const code = res && typeof res.status === "number" ? res.status : 0;
        if (code === 401) {
          toast("bad creds");
          return;
        }
        if (code === 403) {
          toast("verify email");
          return;
        }
        if (code === 429) {
          toast("rate limited");
          return;
        }
        toast("fail");
      }

      const uploadProgressEl = document.getElementById("upload-progress");
      const uploadProgressBar = document.getElementById("upload-progress-bar");
      const uploadProgressLabel = document.getElementById(
        "upload-progress-label"
      );

      function setUploadProgress(percent) {
        const clamped = Math.max(0, Math.min(100, Math.round(percent)));
        uploadProgressLabel.textContent = `${clamped}%`;
        uploadProgressBar.style.width = `${clamped}%`;
        uploadProgressEl.classList.remove("hidden");
      }

      function clearUploadProgress() {
        uploadProgressBar.style.width = "0%";
        uploadProgressLabel.textContent = "0%";
        uploadProgressEl.classList.add("hidden");
      }

      const CHUNK_SIZE = 8 * 1024 * 1024;
      const MAX_PARALLEL_CHUNKS = 4;
      const uploadToggle = document.getElementById("upload-toggle");
      let uploadPaused = false;
      let uploadInProgress = false;
      let uploadCanPause = false;

      function updateUploadToggle() {
        if (!uploadInProgress || !uploadCanPause) {
          uploadToggle.classList.add("hidden");
          return;
        }
        uploadToggle.textContent = uploadPaused ? "Resume" : "Pause";
        uploadToggle.classList.remove("hidden");
      }

      uploadToggle.addEventListener("click", () => {
        if (!uploadInProgress || !uploadCanPause) return;
        uploadPaused = !uploadPaused;
        updateUploadToggle();
        toast(uploadPaused ? "paused" : "resumed", 900);
      });

      function beginUploadUI({ canPause = true } = {}) {
        uploadInProgress = true;
        uploadPaused = false;
        uploadCanPause = !!canPause;
        updateUploadToggle();
        setUploadProgress(0);
        if ("Notification" in window && Notification.permission === "default") {
          Notification.requestPermission().catch(() => {});
        }
      }

      function endUploadUI() {
        uploadInProgress = false;
        uploadPaused = false;
        uploadCanPause = false;
        updateUploadToggle();
        clearUploadProgress();
      }

      function waitWhilePaused() {
        return new Promise((resolve) => {
          const tick = () => {
            if (!uploadPaused) {
              resolve();
              return;
            }
            setTimeout(tick, 150);
          };
          tick();
        });
      }

      async function retry(action, attempts = 4, baseDelayMs = 400) {
        let delayMs = baseDelayMs;
        for (let attempt = 0; attempt < attempts; attempt++) {
          try {
            return await action();
          } catch (_) {
            if (attempt === attempts - 1) throw _;
            await new Promise((resolve) => setTimeout(resolve, delayMs));
            delayMs *= 2;
          }
        }
        throw new Error("retry failed");
      }

      async function safeJson(res) {
        try {
          return await res.json();
        } catch (_) {
          return null;
        }
      }

      function fileUploadKey(file) {
        return `dshare-upload:${file.name}:${file.size}:${file.lastModified}`;
      }

      function loadUploadSession(key) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : null;
        } catch (_) {
          return null;
        }
      }

      function saveUploadSession(key, session) {
        try {
          localStorage.setItem(key, JSON.stringify(session));
        } catch (_) {}
      }

      function clearUploadSession(key) {
        try {
          localStorage.removeItem(key);
        } catch (_) {}
      }

      function base64urlToUint8Array(base64url) {
        const padding = "=".repeat((4 - (base64url.length % 4)) % 4);
        const base64 = (base64url + padding)
          .replace(/-/g, "+")
          .replace(/_/g, "/");
        const raw = atob(base64);
        const out = new Uint8Array(raw.length);
        for (let i = 0; i < raw.length; i++) out[i] = raw.charCodeAt(i);
        return out;
      }

      function uint8ArrayToBase64url(bytes) {
        let binary = "";
        for (let i = 0; i < bytes.length; i++)
          binary += String.fromCharCode(bytes[i]);
        const base64 = btoa(binary);
        return base64
          .replace(/\+/g, "-")
          .replace(/\//g, "_")
          .replace(/=+$/g, "");
      }

      function bufferToBase64url(buf) {
        return uint8ArrayToBase64url(new Uint8Array(buf));
      }

      function preformatCreateOptions(opts) {
        const out = { ...opts };
        out.challenge = base64urlToUint8Array(out.challenge);
        out.user = { ...out.user, id: base64urlToUint8Array(out.user.id) };
        if (out.excludeCredentials) {
          out.excludeCredentials = out.excludeCredentials.map((c) => ({
            ...c,
            id: base64urlToUint8Array(c.id),
          }));
        }
        return out;
      }

      function preformatGetOptions(opts) {
        const out = { ...opts };
        out.challenge = base64urlToUint8Array(out.challenge);
        if (out.allowCredentials) {
          out.allowCredentials = out.allowCredentials.map((c) => ({
            ...c,
            id: base64urlToUint8Array(c.id),
          }));
        }
        return out;
      }

      function credentialToJSON(cred) {
        if (!cred) return null;
        const response = cred.response || {};
        const clientExtensionResults = cred.getClientExtensionResults
          ? cred.getClientExtensionResults()
          : {};
        const rawId = bufferToBase64url(cred.rawId);
        const obj = {
          id: rawId,
          rawId,
          type: cred.type,
          authenticatorAttachment: cred.authenticatorAttachment || null,
          clientExtensionResults,
          response: {
            clientDataJSON: bufferToBase64url(response.clientDataJSON),
          },
        };
        if (response.attestationObject) {
          obj.response.attestationObject = bufferToBase64url(
            response.attestationObject
          );
        }
        if (response.authenticatorData) {
          obj.response.authenticatorData = bufferToBase64url(
            response.authenticatorData
          );
        }
        if (response.signature) {
          obj.response.signature = bufferToBase64url(response.signature);
        }
        if (response.userHandle) {
          obj.response.userHandle = bufferToBase64url(response.userHandle);
        }
        return obj;
      }

      async function postJSON(url, data) {
        const csrftoken = getCsrfToken();
        const res = await fetch(url, {
          method: "POST",
          credentials: "same-origin",
          headers: {
            "Content-Type": "application/json",
            "X-CSRFToken": csrftoken,
          },
          body: JSON.stringify(data || {}),
        });
        return res;
      }

      const modeLabel = document.getElementById("mode-label");
      const accountLabel = document.getElementById("account-label");
      const actionSheet = document.getElementById("action-sheet");
      const actionAccount = document.getElementById("action-account");
      const helpSheet = document.getElementById("help-sheet");
      const openActionsBtn = document.getElementById("open-actions");
      const openActionsLabelBtn = document.getElementById("open-actions-label");

      let authState = { authenticated: false, email: "" };

      function toggleAction(name, visible) {
        if (!actionSheet) return;
        const btn = actionSheet.querySelector(`[data-action="${name}"]`);
        if (!btn) return;
        btn.classList.toggle("hidden", !visible);
      }

      function updateAuthUI(data) {
        authState = {
          authenticated: !!(data && data.authenticated),
          email: data && data.email ? data.email : "",
        };
        if (modeLabel) {
          modeLabel.textContent = authState.authenticated ? "private" : "public";
        }
        if (accountLabel) {
          accountLabel.textContent = authState.authenticated ? authState.email : "";
        }
        if (actionAccount) {
          actionAccount.textContent = authState.authenticated
            ? authState.email
            : "public";
        }
        toggleAction("login", !authState.authenticated);
        toggleAction("register", !authState.authenticated);
        toggleAction("logout", authState.authenticated);
        toggleAction("passkey", authState.authenticated);
      }

      async function refreshMode() {
        try {
          const res = await fetch("/api/auth/me/", { method: "GET" });
          const data = await res.json();
          updateAuthUI(data);
        } catch (_) {}
      }

      function promptField({
        title,
        type = "text",
        placeholder = "",
        inputMode = "",
        autoComplete = "",
      }) {
        return new Promise((resolve) => {
          const modal = document.createElement("div");
          modal.className =
            "fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-90 p-4";
          modal.setAttribute("role", "dialog");
          modal.setAttribute("aria-modal", "true");

          const panel = document.createElement("div");
          panel.className = "dshare-glass w-full max-w-xs rounded-lg p-4";

          const label = document.createElement("div");
          label.className =
            "text-xs uppercase tracking-widest text-white text-opacity-70";
          label.textContent = title || "";

          const input = document.createElement("input");
          input.type = type || "text";
          input.placeholder = placeholder || "";
          input.className =
            "mt-3 w-full rounded border border-white border-opacity-10 bg-black bg-opacity-40 px-3 py-2 text-white outline-none focus:ring-2 focus:ring-white focus:ring-opacity-20";
          if (inputMode) input.inputMode = inputMode;
          if (autoComplete) input.autocomplete = autoComplete;
          input.autocapitalize = "none";
          input.spellcheck = false;

          const actions = document.createElement("div");
          actions.className = "mt-4 flex justify-end gap-2";

          const cancelBtn = document.createElement("button");
          cancelBtn.type = "button";
          cancelBtn.className =
            "rounded border border-white border-opacity-20 px-3 py-2 text-xs uppercase tracking-widest text-white text-opacity-70 hover:bg-white hover:bg-opacity-5";
          cancelBtn.textContent = "Cancel";

          const okBtn = document.createElement("button");
          okBtn.type = "button";
          okBtn.className =
            "rounded border border-white border-opacity-20 px-3 py-2 text-xs uppercase tracking-widest text-white hover:bg-white hover:bg-opacity-10";
          okBtn.textContent = "OK";

          actions.appendChild(cancelBtn);
          actions.appendChild(okBtn);
          panel.appendChild(label);
          panel.appendChild(input);
          panel.appendChild(actions);
          modal.appendChild(panel);
          document.body.appendChild(modal);

          function close(val) {
            modal.remove();
            resolve(val);
          }

          okBtn.addEventListener("click", () => close(input.value));
          cancelBtn.addEventListener("click", () => close(null));
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") close(input.value);
            if (e.key === "Escape") close(null);
          });
          modal.addEventListener("click", (e) => {
            if (e.target === modal) close(null);
          });

          input.focus();
        });
      }

      function promptPassword(message, opts = {}) {
        return promptField({
          title: message,
          type: "password",
          placeholder: "••••••••",
          inputMode: opts.inputMode || "",
          autoComplete: opts.autoComplete || "current-password",
        });
      }

      async function promptEmail(message = "Email") {
        const value = await promptField({
          title: message,
          type: "email",
          placeholder: "you@example.com",
          inputMode: "email",
          autoComplete: "email",
        });
        return value ? value.trim() : null;
      }

      async function commandRegister() {
        const email = await promptEmail("Email");
        if (!email) return;

        let canLogin = false;
        try {
          const statusRes = await postJSON("/api/auth/email-status/", {
            email,
          });
          const statusData = await statusRes.json();
          canLogin =
            statusRes.ok &&
            statusData &&
            statusData.status === "ok" &&
            !!statusData.can_login;
        } catch (_) {}

        if (canLogin) {
          const secret = await promptPassword("Enter password or pin");
          if (!secret) {
            toast("fail");
            return;
          }
          const res = await postJSON("/api/auth/login/", { email, secret });
          let data = null;
          try {
            data = await res.json();
          } catch (_) {}
          if (res.ok && data && data.status === "ok") {
            toast("ok");
            await refreshMode();
            return;
          }
          toastAuthFailure(res);
          return;
        }

        const password = await promptPassword("Create password", {
          autoComplete: "new-password",
        });
        if (!password) {
          toast("fail");
          return;
        }
        const pin =
          (await promptPassword("Create pin (optional)", {
            inputMode: "numeric",
            autoComplete: "off",
          })) || "";
        const res = await postJSON("/api/auth/register/", {
          email,
          password,
          pin,
        });
        let data = null;
        try {
          data = await res.json();
        } catch (_) {}
        if (res.ok && data && data.status === "ok") {
          toast("sent");
          return;
        }
        if (data && data.detail) console.error(data.detail);
        toast("fail");
      }

      async function tryPasskeyLogin() {
        if (!window.PublicKeyCredential) return false;
        try {
          const begin = await postJSON("/api/webauthn/auth/begin/", {});
          if (!begin.ok) return false;
          const options = await begin.json();
          const publicKey = preformatGetOptions(options.publicKey);
          const assertion = await navigator.credentials.get({ publicKey });
          const payload = credentialToJSON(assertion);
          const complete = await postJSON(
            "/api/webauthn/auth/complete/",
            payload
          );
          if (!complete.ok) return false;
          const out = await complete.json();
          return out && out.status === "ok";
        } catch (_) {
          return false;
        }
      }

      async function commandLogin() {
        const passkeyOk = await tryPasskeyLogin();
        if (passkeyOk) {
          toast("ok");
          await refreshMode();
          return;
        }

        const email = await promptEmail("Email");
        if (!email) return;
        const secret = await promptPassword("Enter password or pin");
        if (!secret) {
          toast("fail");
          return;
        }
        const res = await postJSON("/api/auth/login/", { email, secret });
        let data = null;
        try {
          data = await res.json();
        } catch (_) {}
        if (res.ok && data && data.status === "ok") {
          toast("ok");
          await refreshMode();
          return;
        }
        toastAuthFailure(res);
      }

      async function commandLogout() {
        const res = await postJSON("/api/auth/logout/", {});
        toast(res.ok ? "ok" : "fail");
        await refreshMode();
      }

      async function commandPasskey() {
        if (!window.PublicKeyCredential) {
          toast("fail");
          return;
        }
        try {
          const begin = await postJSON("/api/webauthn/register/begin/", {});
          if (!begin.ok) {
            toast("fail");
            return;
          }
          const options = await begin.json();
          const publicKey = preformatCreateOptions(options.publicKey);
          const cred = await navigator.credentials.create({ publicKey });
          const payload = credentialToJSON(cred);
          const complete = await postJSON(
            "/api/webauthn/register/complete/",
            payload
          );
          toast(complete.ok ? "ok" : "fail");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandCopy() {
        try {
          const res = await fetch("/api/share/text/", { method: "GET" });
          const data = await res.json();
          const text = data && data.text ? data.text : "";
          await navigator.clipboard.writeText(text);
          toast("ok");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandClear() {
        try {
          await postJSON("/api/share/clear/", {});
          try {
            await navigator.clipboard.writeText("");
          } catch (_) {}
          toast("ok");
        } catch (_) {
          toast("fail");
        }
      }

      let lastHintAt = 0;
      function showQuickHint() {
        const now = Date.now();
        if (now - lastHintAt < 1200) return;
        lastHintAt = now;
        toast(
          "tap logo • hold = actions\n↑ upload (divya)   ↓ download (moti)\n← copy   → paste",
          2600
        );
      }

      async function commandHelp() {
        showHelpSheet();
      }

      async function commandStatus() {
        try {
          const res = await fetch("/api/auth/me/", { method: "GET" });
          const data = await res.json();
          toast(data && data.authenticated ? "private" : "public");
        } catch (_) {
          toast("fail");
        }
      }

      async function commandMe() {
        try {
          const res = await fetch("/api/auth/me/", { method: "GET" });
          const data = await res.json();
          if (!data || !data.authenticated) {
            toast("me: public");
            return;
          }
          const email = data.email || "";
          const summary = `me: ${email} verified=${!!data.email_verified} passkey=${!!data.has_passkey} pw=${!!data.has_password} pin=${!!data.has_pin}`;
          toast(summary, 3000);
        } catch (_) {
          toast("fail");
        }
      }

      async function handleCommand(cmd) {
        if (cmd === "register") return commandRegister();
        if (cmd === "login") return commandLogin();
        if (cmd === "logout") return commandLogout();
        if (cmd === "passkey") return commandPasskey();
        if (cmd === "status") return commandStatus();
        if (cmd === "me") return commandMe();
        if (cmd === "copy") return commandCopy();
        if (cmd === "paste") return pasteText();
        if (cmd === "clear") return commandClear();
        if (cmd === "docs") return openDocs();
        if (cmd === "help" || cmd === "?") return commandHelp();
        toast("fail");
      }

      function openUploadPanel() {
        document.getElementById("upload-section").classList.remove("hidden");
        keyword = "";
      }

      function triggerDownload() {
        window.location.href = "/download/";
      }

      function openDocs() {
        try {
          window.open("https://docs.dshare.me", "_blank", "noopener,noreferrer");
        } catch (_) {
          window.location.href = "https://docs.dshare.me";
        }
      }

      function showHelpSheet() {
        if (!helpSheet) return;
        hideActionSheet();
        helpSheet.classList.remove("hidden");
      }

      function hideHelpSheet() {
        if (!helpSheet) return;
        helpSheet.classList.add("hidden");
      }

      function showActionSheet() {
        if (!actionSheet) return;
        hideHelpSheet();
        actionSheet.classList.remove("hidden");
      }

      function hideActionSheet() {
        if (!actionSheet) return;
        actionSheet.classList.add("hidden");
      }

      if (openActionsBtn) {
        openActionsBtn.addEventListener("click", (e) => {
          e.preventDefault();
          showActionSheet();
        });
      }
      if (openActionsLabelBtn) {
        openActionsLabelBtn.addEventListener("click", (e) => {
          e.preventDefault();
          showActionSheet();
        });
      }

      if (actionSheet) {
        actionSheet.addEventListener("click", (e) => {
          if (e.target === actionSheet) hideActionSheet();
        });
        const closeBtn = document.getElementById("action-close");
        if (closeBtn) closeBtn.addEventListener("click", hideActionSheet);
        actionSheet.querySelectorAll("[data-action]").forEach((btn) => {
          btn.addEventListener("click", () => {
            const action = btn.getAttribute("data-action");
            hideActionSheet();
            if (!action) return;
            if (action === "upload") return openUploadPanel();
            if (action === "download") return triggerDownload();
            return handleCommand(action);
          });
        });
      }

      if (helpSheet) {
        helpSheet.addEventListener("click", (e) => {
          if (e.target === helpSheet) hideHelpSheet();
        });
        const helpCloseBtn = document.getElementById("help-close");
        if (helpCloseBtn) helpCloseBtn.addEventListener("click", hideHelpSheet);
      }

      document.addEventListener("keydown", function (e) {
        const active = document.activeElement;
        if (
          active &&
          (active.tagName === "INPUT" || active.tagName === "TEXTAREA")
        )
          return;
        if (e.key.length !== 1) return;
        keyword += e.key.toLowerCase();
        if (keyword.length > 64) keyword = keyword.slice(-64);

        if (keyword.includes(specialKeywordUpload)) {
          document.getElementById("upload-section").classList.remove("hidden");
          keyword = ""; // Reset keyword
        }
        if (keyword.includes(specialKeywordDownload)) {
          window.location.href = "/download/";
          keyword = ""; // Reset keyword
        }

        for (const prefix of COMMAND_PREFIXES) {
          const idx = keyword.lastIndexOf(prefix);
          if (idx === -1) continue;
          const maybe = keyword.slice(idx + 1);
          const known = [
            "register",
            "login",
            "logout",
            "passkey",
            "status",
            "me",
            "copy",
            "paste",
            "clear",
            "docs",
            "help",
            "?",
          ];
          if (known.includes(maybe)) {
            keyword = "";
            handleCommand(maybe);
            break;
          }
        }
      });

      async function pasteText() {
        try {
          const text = await navigator.clipboard.readText();
          const formData = new FormData();
          formData.append("text", text);
          const response = await fetch("/upload/", {
            method: "POST",
            credentials: "same-origin",
            body: formData,
            headers: {
              "X-CSRFToken": getCsrfToken(),
            },
          });
          let data = null;
          try {
            data = await response.json();
          } catch (_) {}
          toast(response.ok && data && data.status === "ok" ? "ok" : "fail");
        } catch (_) {
          toast("fail");
        }
      }

      function chunkSizeForIndex(file, index, chunkSize) {
        const start = index * chunkSize;
        return Math.min(chunkSize, file.size - start);
      }

      async function startUploadSession(file, cached) {
        const payload = {
          filename: file.name,
          size: file.size,
          chunk_size: CHUNK_SIZE,
          content_type: file.type || "",
        };
        if (cached && cached.upload_id) {
          payload.upload_id = cached.upload_id;
        }
        const res = await postJSON("/api/upload/start/", payload);
        const data = await res.json();
        if (!res.ok || !data || data.status !== "ok") {
          throw new Error("upload start failed");
        }
        return data;
      }

      async function uploadChunkedFile(file) {
        if (!file || file.size <= 0) {
          throw new Error("empty file");
        }

        const key = fileUploadKey(file);
        const cached = loadUploadSession(key);
        const session = await retry(() => startUploadSession(file, cached));
        saveUploadSession(key, {
          upload_id: session.upload_id,
          chunk_size: session.chunk_size,
        });

        const chunkSize = session.chunk_size || CHUNK_SIZE;
        const totalChunks = session.total_chunks;
        const received = new Set(session.received_chunks || []);
        let uploadedBytes = 0;
        for (const idx of received) {
          if (typeof idx !== "number") continue;
          uploadedBytes += chunkSizeForIndex(file, idx, chunkSize);
        }
        setUploadProgress((uploadedBytes / file.size) * 100);

        async function uploadChunkAt(index) {
          await waitWhilePaused();
          const start = index * chunkSize;
          const chunk = file.slice(start, start + chunkSize);
          const formData = new FormData();
          formData.append("upload_id", session.upload_id);
          formData.append("index", String(index));
          formData.append("chunk", chunk, file.name);
          const res = await fetch("/api/upload/chunk/", {
            method: "POST",
            credentials: "same-origin",
            headers: {
              "X-CSRFToken": getCsrfToken(),
            },
            body: formData,
          });
          if (!res.ok) {
            throw new Error("chunk upload failed");
          }
          return chunk.size;
        }

        const missing = [];
        for (let index = 0; index < totalChunks; index++) {
          if (!received.has(index)) missing.push(index);
        }

        let concurrency = Math.floor((navigator.hardwareConcurrency || 4) / 2);
        concurrency = Math.max(1, Math.min(MAX_PARALLEL_CHUNKS, concurrency));
        concurrency = Math.min(concurrency, missing.length || 1);

        let next = 0;
        async function worker() {
          while (true) {
            const index = missing[next++];
            if (index === undefined) return;
            const sent = await retry(() => uploadChunkAt(index));
            received.add(index);
            uploadedBytes += sent;
            setUploadProgress((uploadedBytes / file.size) * 100);
          }
        }

        await Promise.all(Array.from({ length: concurrency }, worker));

        let complete = await retry(() =>
          postJSON("/api/upload/complete/", {
            upload_id: session.upload_id,
          })
        );
        let completeData = await safeJson(complete);
        if (
          !complete.ok &&
          complete.status === 409 &&
          completeData &&
          Array.isArray(completeData.missing_chunks)
        ) {
          const missingAgain = completeData.missing_chunks.filter(
            (idx) => typeof idx === "number"
          );

          let nextMissing = 0;
          async function reuploadWorker() {
            while (true) {
              const idx = missingAgain[nextMissing++];
              if (idx === undefined) return;
              await retry(() => uploadChunkAt(idx));
            }
          }
          await Promise.all(
            Array.from(
              { length: Math.min(concurrency, missingAgain.length || 1) },
              reuploadWorker
            )
          );
          complete = await retry(() =>
            postJSON("/api/upload/complete/", {
              upload_id: session.upload_id,
            })
          );
          completeData = await safeJson(complete);
        }
        if (!complete.ok || !completeData || completeData.status !== "ok") {
          throw new Error("upload complete failed");
        }
        clearUploadSession(key);
        return true;
      }

      function uploadDirectFile(file) {
        if (!file || file.size <= 0) {
          return Promise.reject(new Error("empty file"));
        }
        return new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          xhr.open("POST", "/upload/", true);
          xhr.withCredentials = true;
          xhr.timeout = 1000 * 60 * 30;
          try {
            xhr.setRequestHeader("X-CSRFToken", getCsrfToken());
          } catch (_) {}

          xhr.upload.onprogress = (e) => {
            if (!e || !e.lengthComputable) return;
            setUploadProgress((e.loaded / e.total) * 100);
          };

          xhr.onload = () => {
            let data = null;
            try {
              data = JSON.parse(xhr.responseText || "{}");
            } catch (_) {}
            if (xhr.status >= 200 && xhr.status < 300 && data && data.status === "ok") {
              resolve(true);
              return;
            }
            reject(new Error("direct upload failed"));
          };
          xhr.onerror = () => reject(new Error("direct upload failed"));
          xhr.ontimeout = () => reject(new Error("direct upload timeout"));

          const formData = new FormData();
          formData.append("file", file, file.name);
          xhr.send(formData);
        });
      }

      async function uploadFileSmart(file) {
        const smallFile = file && file.size <= CHUNK_SIZE * 2;
        if (smallFile) {
          beginUploadUI({ canPause: false });
          try {
            await retry(() => uploadDirectFile(file), 2, 600);
            return true;
          } catch (err) {
            console.error(err);
            toast("retry", 900);
            setUploadProgress(0);
            uploadCanPause = true;
            updateUploadToggle();
            await uploadChunkedFile(file);
            return true;
          }
        }

        beginUploadUI({ canPause: true });
        try {
          await uploadChunkedFile(file);
          return true;
        } catch (err) {
          console.error(err);
          toast("fallback", 1200);
          uploadCanPause = false;
          updateUploadToggle();
          setUploadProgress(0);
          await retry(() => uploadDirectFile(file), 2, 700);
          return true;
        }
      }

      document
        .getElementById("upload-form")
        .addEventListener("submit", function (e) {
          e.preventDefault();
          if (uploadInProgress) {
            toast("busy");
            return;
          }
          const fileInput = this.querySelector('input[type="file"]');
          const file = fileInput && fileInput.files ? fileInput.files[0] : null;
          if (!file) {
            toast("fail");
            return;
          }
          uploadFileSmart(file)
            .then(() => {
              toast("ok");
              if (
                "Notification" in window &&
                Notification.permission === "granted"
              ) {
                new Notification("DShare", { body: "Upload complete." });
              }
            })
            .catch(() => toast("fail"))
            .finally(() => {
              endUploadUI();
            });
        });

      refreshMode();

      const params = new URLSearchParams(window.location.search);
      if (params.get("verified") === "1" || params.get("setup") === "passkey") {
        toast("ok");
        params.delete("verified");
        params.delete("setup");
        const q = params.toString();
        const clean = q
          ? `${window.location.pathname}?${q}`
          : window.location.pathname;
        window.history.replaceState({}, "", clean);
      }

      // --- Gesture Recognition (Ported from Flutter) ---
      class Point { constructor(x, y) { this.x = x; this.y = y; } }
      class Recognizer {
        constructor() {
          this.points = [];
          this.templates = [
            { name: 'UP', points: [new Point(0, 100), new Point(0, 0)] },
            { name: 'ARROW_UP', points: [new Point(0, 100), new Point(50, 0), new Point(100, 100)] },
            { name: 'DOWN', points: [new Point(0, 0), new Point(0, 100)] },
            { name: 'ARROW_DOWN', points: [new Point(0, 0), new Point(50, 100), new Point(100, 0)] },
            { name: 'L', points: [new Point(0, 0), new Point(0, 100), new Point(50, 100)] },
            { name: 'R', points: [new Point(0, 100), new Point(0, 0), new Point(50, 0), new Point(50, 50), new Point(0, 50), new Point(50, 100)] },
            { name: 'P', points: [new Point(0, 100), new Point(0, 0), new Point(50, 0), new Point(50, 50), new Point(0, 50)] },
            { name: 'C', points: [new Point(100, 0), new Point(0, 50), new Point(100, 100)] },
            { name: 'S', points: [new Point(100, 0), new Point(0, 30), new Point(100, 70), new Point(0, 100)] },
            { name: 'M', points: [new Point(0, 100), new Point(0, 0), new Point(50, 50), new Point(100, 0), new Point(100, 100)] },
            { name: 'H', points: [new Point(0, 0), new Point(0, 100), new Point(0, 50), new Point(100, 50), new Point(100, 0), new Point(100, 100)] },
            { name: 'K', points: [new Point(0, 0), new Point(0, 100), new Point(0, 50), new Point(50, 0), new Point(0, 50), new Point(50, 100)] },
          ];
          // Pre-process templates
          const numPoints = 64;
          const squareSize = 250.0;
          this.templates = this.templates.map(t => ({
             name: t.name,
             points: this.normalize(t.points, numPoints, squareSize)
          }));
          this.numPoints = numPoints;
          this.squareSize = squareSize;
        }

        recognize(points) {
          if (points.length < 10) return null;
          points = this.normalize(points, this.numPoints, this.squareSize);
          let bestDist = Infinity;
          let bestName = '';
          for (const t of this.templates) {
            const d = this.distanceAtBestAngle(points, t.points);
            if (d < bestDist) {
               bestDist = d;
               bestName = t.name;
            }
          }
          const score = 1.0 - (bestDist / (0.5 * Math.sqrt(this.squareSize*this.squareSize + this.squareSize*this.squareSize)));
          return { name: bestName, score: score };
        }

        normalize(points, n, size) {
           return this.translateToOrigin(this.scaleToSquare(this.rotateToZero(this.resample(points, n)), size));
        }

        resample(points, n) {
           let I = this.pathLength(points) / (n - 1);
           let D = 0.0;
           let newPoints = [points[0]];
           for (let i = 1; i < points.length; i++) {
               let d = this.distance(points[i-1], points[i]);
               if (D + d >= I) {
                   let qx = points[i-1].x + ((I - D) / d) * (points[i].x - points[i-1].x);
                   let qy = points[i-1].y + ((I - D) / d) * (points[i].y - points[i-1].y);
                   let q = new Point(qx, qy);
                   newPoints.push(q);
                   points.splice(i, 0, q);
                   D = 0.0;
               } else { D += d; }
           }
           if (newPoints.length === n - 1) newPoints.push(points[points.length - 1]);
           return newPoints;
        }
        
        rotateToZero(points) {
            const c = this.centroid(points);
            const theta = Math.atan2(c.y - points[0].y, c.x - points[0].x);
            return this.rotateBy(points, -theta);
        }
        
        rotateBy(points, rads) {
            const c = this.centroid(points);
            const cos = Math.cos(rads);
            const sin = Math.sin(rads);
            return points.map(p => new Point(
                (p.x - c.x) * cos - (p.y - c.y) * sin + c.x,
                (p.x - c.x) * sin + (p.y - c.y) * cos + c.y
            ));
        }

        scaleToSquare(points, size) {
            const b = this.boundingBox(points);
            const w = b.w === 0 ? 1 : b.w;
            const h = b.h === 0 ? 1 : b.h;
            return points.map(p => new Point(p.x * (size / w), p.y * (size / h)));
        }

        translateToOrigin(points) {
            const c = this.centroid(points);
            return points.map(p => new Point(p.x - c.x, p.y - c.y));
        }
        
        distanceAtBestAngle(points, T) {
            let a = -45.0 * (Math.PI / 180.0);
            let b = 45.0 * (Math.PI / 180.0);
            const phi = 0.618033988749895;
            let x1 = phi * a + (1.0 - phi) * b;
            let f1 = this.distanceAtAngle(points, T, x1);
            let x2 = (1.0 - phi) * a + phi * b;
            let f2 = this.distanceAtAngle(points, T, x2);
            while (Math.abs(b - a) > 2.0 * (Math.PI / 180.0)) {
                if (f1 < f2) {
                    b = x2; x2 = x1; f2 = f1;
                    x1 = phi * a + (1.0 - phi) * b;
                    f1 = this.distanceAtAngle(points, T, x1);
                } else {
                    a = x1; x1 = x2; f1 = f2;
                    x2 = (1.0 - phi) * a + phi * b;
                    f2 = this.distanceAtAngle(points, T, x2);
                }
            }
            return Math.min(f1, f2);
        }

        distanceAtAngle(points, T, rads) {
            let newPoints = this.rotateBy(points, rads);
            let d = 0.0;
            for (let i = 0; i < points.length; i++) d += this.distance(newPoints[i], T[i]);
            return d / points.length;
        }

        pathLength(points) {
            let d = 0.0;
            for (let i = 1; i < points.length; i++) d += this.distance(points[i-1], points[i]);
            return d;
        }

        distance(p1, p2) {
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }

        centroid(points) {
            let x = 0, y = 0;
            for (const p of points) { x += p.x; y += p.y; }
            return new Point(x / points.length, y / points.length);
        }

        boundingBox(points) {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            for (const p of points) {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            }
            return { w: maxX - minX, h: maxY - minY };
        }
      }

      // --- Interaction ---
      const recognizer = new Recognizer();
      let stroke = [];
      const canvas = document.getElementById('gesture-canvas');
      const ctx = canvas.getContext('2d');
      let isDrawing = false;

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      function drawStroke() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (stroke.length < 2) return;
        ctx.beginPath();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.moveTo(stroke[0].x, stroke[0].y);
        for (let i = 1; i < stroke.length; i++) ctx.lineTo(stroke[i].x, stroke[i].y);
        ctx.stroke();
      }

      const DRAW_THRESHOLD = 14;
      const LONG_PRESS_MS = 420;
      let activePointerId = null;
      let activePointerTarget = null;
      let strokeMoved = false;
      let longPressTimer = null;
      let longPressTriggered = false;

      function isInteractiveTarget(target) {
        if (!target || !target.closest) return false;
        if (target.closest("#action-sheet")) return true;
        if (target.closest("#help-sheet")) return true;
        return !!target.closest("button, input, textarea, select, a, label");
      }

      function beginStroke(x, y) {
        stroke = [new Point(x, y)];
        isDrawing = true;
        strokeMoved = false;
        longPressTriggered = false;
      }

      function extendStroke(x, y) {
        if (!isDrawing) return;
        stroke.push(new Point(x, y));
        if (!strokeMoved) {
          const dx = x - stroke[0].x;
          const dy = y - stroke[0].y;
          if (Math.hypot(dx, dy) > DRAW_THRESHOLD) {
            strokeMoved = true;
            clearLongPressTimer();
          }
        }
        requestAnimationFrame(drawStroke);
      }

      function startLongPressTimer() {
        clearLongPressTimer();
        longPressTimer = setTimeout(() => {
          if (strokeMoved || !isDrawing) return;
          longPressTriggered = true;
          cancelStroke();
          showActionSheet();
        }, LONG_PRESS_MS);
      }

      function clearLongPressTimer() {
        if (longPressTimer) {
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
      }

      function verticalSwipeDirection(points) {
        if (!points || points.length < 2) return null;
        const minDy = Math.max(50, window.innerHeight * 0.06);
        const maxDx = Math.max(220, window.innerWidth * 0.65);
        let minX = points[0].x;
        let maxX = points[0].x;
        let minY = points[0].y;
        let maxY = points[0].y;
        let sumAbsDx = 0;
        let sumAbsDy = 0;
        let posDySegments = 0;
        let negDySegments = 0;
        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1];
          const curr = points[i];
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          sumAbsDx += Math.abs(dx);
          sumAbsDy += Math.abs(dy);
          if (dy > 2) {
            posDySegments += 1;
          } else if (dy < -2) {
            negDySegments += 1;
          }
          if (curr.x < minX) minX = curr.x;
          if (curr.x > maxX) maxX = curr.x;
          if (curr.y < minY) minY = curr.y;
          if (curr.y > maxY) maxY = curr.y;
        }
        const dxRange = maxX - minX;
        const dyRange = maxY - minY;
        if (dyRange < minDy) return null;
        if (dxRange > maxDx) return null;
        if (sumAbsDy <= 0) return null;
        const dominance = sumAbsDx === 0 ? Infinity : (sumAbsDy / sumAbsDx);
        if (dominance < 1.05) return null;
        const totalDy = posDySegments + negDySegments;
        if (totalDy > 0) {
          const dominant = Math.max(posDySegments, negDySegments) / totalDy;
          if (dominant < 0.6) return null;
        }
        const netDy = points[points.length - 1].y - points[0].y;
        if (Math.abs(netDy) < dyRange * 0.35) return null;
        return netDy < 0 ? "UP" : "DOWN";
      }

      function verticalSwipeFallback(points) {
        if (!points || points.length < 2) return null;
        const minDy = Math.max(40, window.innerHeight * 0.05);
        const netDy = points[points.length - 1].y - points[0].y;
        const netDx = points[points.length - 1].x - points[0].x;
        if (Math.abs(netDy) < minDy) return null;
        if (Math.abs(netDy) < Math.abs(netDx) * 1.1) return null;
        return netDy < 0 ? "UP" : "DOWN";
      }

      function horizontalSwipeDirection(points) {
        if (!points || points.length < 2) return null;
        const minDx = Math.max(50, window.innerWidth * 0.06);
        const maxDy = Math.max(220, window.innerHeight * 0.65);
        let minX = points[0].x;
        let maxX = points[0].x;
        let minY = points[0].y;
        let maxY = points[0].y;
        let sumAbsDx = 0;
        let sumAbsDy = 0;
        let posDxSegments = 0;
        let negDxSegments = 0;
        for (let i = 1; i < points.length; i++) {
          const prev = points[i - 1];
          const curr = points[i];
          const dx = curr.x - prev.x;
          const dy = curr.y - prev.y;
          sumAbsDx += Math.abs(dx);
          sumAbsDy += Math.abs(dy);
          if (dx > 2) {
            posDxSegments += 1;
          } else if (dx < -2) {
            negDxSegments += 1;
          }
          if (curr.x < minX) minX = curr.x;
          if (curr.x > maxX) maxX = curr.x;
          if (curr.y < minY) minY = curr.y;
          if (curr.y > maxY) maxY = curr.y;
        }
        const dxRange = maxX - minX;
        const dyRange = maxY - minY;
        if (dxRange < minDx) return null;
        if (dyRange > maxDy) return null;
        if (sumAbsDx <= 0) return null;
        const dominance = sumAbsDy === 0 ? Infinity : (sumAbsDx / sumAbsDy);
        if (dominance < 1.05) return null;
        const totalDx = posDxSegments + negDxSegments;
        if (totalDx > 0) {
          const dominant = Math.max(posDxSegments, negDxSegments) / totalDx;
          if (dominant < 0.6) return null;
        }
        const netDx = points[points.length - 1].x - points[0].x;
        if (Math.abs(netDx) < dxRange * 0.35) return null;
        return netDx < 0 ? "LEFT" : "RIGHT";
      }

      function horizontalSwipeFallback(points) {
        if (!points || points.length < 2) return null;
        const minDx = Math.max(40, window.innerWidth * 0.05);
        const netDx = points[points.length - 1].x - points[0].x;
        const netDy = points[points.length - 1].y - points[0].y;
        if (Math.abs(netDx) < minDx) return null;
        if (Math.abs(netDx) < Math.abs(netDy) * 1.1) return null;
        return netDx < 0 ? "LEFT" : "RIGHT";
      }

      function finishStroke() {
        if (!isDrawing) return;
        isDrawing = false;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        clearLongPressTimer();

        const vertical = verticalSwipeDirection(stroke);
        if (vertical === "UP") {
          openUploadPanel();
          stroke = [];
          return;
        }
        if (vertical === "DOWN") {
          triggerDownload();
          stroke = [];
          return;
        }

        const fallback = verticalSwipeFallback(stroke);
        if (fallback === "UP") {
          openUploadPanel();
          stroke = [];
          return;
        }
        if (fallback === "DOWN") {
          triggerDownload();
          stroke = [];
          return;
        }

        const horizontal = horizontalSwipeDirection(stroke);
        if (horizontal === "LEFT") {
          commandCopy();
          stroke = [];
          return;
        }
        if (horizontal === "RIGHT") {
          pasteText();
          stroke = [];
          return;
        }

        const horizontalFallback = horizontalSwipeFallback(stroke);
        if (horizontalFallback === "LEFT") {
          commandCopy();
          stroke = [];
          return;
        }
        if (horizontalFallback === "RIGHT") {
          pasteText();
          stroke = [];
          return;
        }

        stroke = [];
        toast("hold (or tap logo) for actions");
      }

      function cancelStroke() {
        if (!isDrawing) return;
        isDrawing = false;
        stroke = [];
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        clearLongPressTimer();
      }

      function onPointerDown(e) {
        if (activePointerId !== null) return;
        if (e.pointerType === 'mouse' && e.button !== 0) return;
        if (isInteractiveTarget(e.target)) return;
        activePointerId = e.pointerId;
        activePointerTarget = e.target;
        if (activePointerTarget && activePointerTarget.setPointerCapture) {
          activePointerTarget.setPointerCapture(e.pointerId);
        }
        beginStroke(e.clientX, e.clientY);
        startLongPressTimer();
      }

      function onPointerMove(e) {
        if (!isDrawing || e.pointerId !== activePointerId) return;
        extendStroke(e.clientX, e.clientY);
        if (strokeMoved) e.preventDefault();
      }

      function clearPointerCapture() {
        if (
          activePointerTarget &&
          activePointerTarget.releasePointerCapture &&
          activePointerId !== null
        ) {
          try {
            activePointerTarget.releasePointerCapture(activePointerId);
          } catch (_) {}
        }
        activePointerId = null;
        activePointerTarget = null;
        strokeMoved = false;
      }

      function onPointerUp(e) {
        if (e.pointerId !== activePointerId) return;
        finishStroke();
        clearPointerCapture();
      }

      function onPointerCancel(e) {
        if (e.pointerId !== activePointerId) return;
        cancelStroke();
        clearPointerCapture();
      }

      function onTouchStart(e) {
        if (e.touches.length > 1) return;
        if (isInteractiveTarget(e.target)) return;
        beginStroke(e.touches[0].clientX, e.touches[0].clientY);
        startLongPressTimer();
      }

      function onTouchMove(e) {
        if (!isDrawing) return;
        extendStroke(e.touches[0].clientX, e.touches[0].clientY);
        if (strokeMoved) e.preventDefault();
      }

      function onTouchEnd() {
        finishStroke();
      }

      function onTouchCancel() {
        cancelStroke();
      }

      // Tap handler for help (if not clicking something else)
      document.addEventListener("click", (e) => {
        if (actionSheet && !actionSheet.classList.contains("hidden")) return;
        if (helpSheet && !helpSheet.classList.contains("hidden")) return;
        if (isInteractiveTarget(e.target)) return;
        showQuickHint();
      });

      if ("PointerEvent" in window) {
        document.addEventListener('pointerdown', onPointerDown, { passive: false });
        document.addEventListener('pointermove', onPointerMove, { passive: false });
        document.addEventListener('pointerup', onPointerUp, { passive: false });
        document.addEventListener('pointercancel', onPointerCancel, { passive: false });
      } else {
        document.addEventListener('touchstart', onTouchStart, { passive: false });
        document.addEventListener('touchmove', onTouchMove, { passive: false });
        document.addEventListener('touchend', onTouchEnd, { passive: false });
        document.addEventListener('touchcancel', onTouchCancel, { passive: false });
      }
    </script>
  </body>
</html>
